""" Single-step-multi-label, human clarification, Saycan environment

Generate a dataset of prompts for SayCan tasks.

Possible categories of tasks:
1. Unambiguous tasks with template
    e.g.,"Bring me {numeric} {object}, please."
2. Creative unambiguous tasks generated by GPT-4 with labels
    e.g., "I'm craving something with a little heat." â€” jalapeno chips
3. Ambiguous tasks
    e.g., "Bring me a cola" --- ['Coke', 'Pepsi']
4. Spatially ambiguous tasks
    e.g., Put {object} between {object} and chips - but chips can be any of the kettle, jalapeno, rice, and multigrain ones
5. Ambiguous tasks that without clarification, an arbitrary action can be unsafe or lead to very undesirable consequences
    e.g, Can you throw away the soda? It should have expired. - but there are different sodas
6. Creative ambiguous tasks generated by GPT-4 with labels
    e.g., "Bring me a healthy snack" --- ['apple', 'banana', 'multigrain chips']

"""
import os
import logging
import argparse
import json
import pickle
import random
from omegaconf import OmegaConf


def extract_all_object_from_tags(d, tags):
    out = {}
    for obj, value in d.items():
        if set(value.tag).intersection(set(tags)):
            out[obj] = value
    return out


def main(cfg):
    target_num_obj = cfg.target_num_obj

    # Load possible tasks
    task_ratio = {}
    for task_type, task_cfg in cfg.task.items():
        task_ratio[task_type] = task_cfg.ratio

        # Load data from json
        if hasattr(task_cfg, 'file_path'):
            with open(task_cfg.file_path, 'r') as f:
                task_cfg.task_with_labels = json.load(f)

    # Sample tasks
    init_data_all = []
    for data_ind in range(cfg.num_data):

        # Sample task category
        task_category = random.choices(
            list(task_ratio.keys()), weights=list(task_ratio.values())
        )[0]

        # Sample the task
        task_cfg = cfg.task[task_category]

        # Deal with winograd tasks separately
        if task_category == 'winograd_task':
            task_prompt = random.choice(list(task_cfg.template.keys()))
            task_prompt_cfg = task_cfg.template[task_prompt]

            if 'include_object' in task_prompt_cfg:
                true_intent = [task_prompt_cfg.include_object]
            elif 'include_tag' in task_prompt_cfg:
                possible_labels = extract_all_object_from_tags(
                    cfg.object, tags=task_prompt_cfg.include_tag
                )
                true_intent = [random.choice(list(possible_labels.keys()))]
            else:
                raise 'No object or tag specified in the task prompt for winograd task.'
            target_loc = task_prompt_cfg.target
            object_to_be_moved = true_intent[0]

            # Fill in one of the object with true intent
            fill_in_tag = random.choice([1, 2])
            task_prompt = task_prompt.replace(
                '{object' + str(fill_in_tag) + '}', true_intent[0]
            )

            # No ambiguous labels
            ambiguous_intent = []

            # Include the true label in the scene
            scene_objects = [true_intent[0]]

            # No special scene description
            special_scene_description = ''

        # Deal with spatially ambiguous tasks separately - quite corner cases
        elif hasattr(task_cfg, 'rel'):
            task_prompt = random.choice(list(task_cfg.template.keys()))
            task_prompt_cfg = task_cfg.template[task_prompt]

            # Determine true label(s) and ambiguous labels
            possible_labels = extract_all_object_from_tags(
                cfg.object, tags=task_prompt_cfg.true_label_tag
            )
            if task_cfg.fixed_label:
                true_intent = [random.choice(list(possible_labels.keys()))]
                ambiguous_intent = [
                    label for label in possible_labels
                    if label not in true_intent
                ]
            else:
                true_intent = list(possible_labels.keys())
                ambiguous_intent = list(possible_labels.keys())

            # target location
            if 'drawer' in task_prompt:
                target_loc = random.choice(
                    list(
                        extract_all_object_from_tags(
                            cfg.object, tags=['drawer']
                        ).keys()
                    )
                )
            else:  # e.g., close to soda
                target_loc = true_intent[0]

            # Sample objects to fill in the task request
            possible_objects = extract_all_object_from_tags(
                cfg.object, tags=task_prompt_cfg.fill_obj_tag
            )
            fill_in_objs = random.sample(
                list(possible_objects.keys()), task_prompt_cfg.num_fill_obj
            )
            for fill_in_obj in fill_in_objs:
                task_prompt = task_prompt.replace('{object}', fill_in_obj, 1)
                object_to_be_moved = fill_in_obj

            # Sample spatial relation if needed
            if '{rel}' in task_prompt:
                rel = random.choice(task_cfg.rel)
                task_prompt = task_prompt.replace('{rel}', rel)

            # Sample objects in the scene
            scene_objects = fill_in_objs
            if task_cfg.fixed_label:
                scene_objects.append(true_intent[0])
                scene_objects.append(random.choice(ambiguous_intent))
            else:
                scene_objects += random.sample(true_intent, 2)

            # No special scene description
            special_scene_description = ''

        elif hasattr(task_cfg, 'template'):
            task_prompt = random.choice(list(task_cfg.template.keys()))
            task_prompt_cfg = task_cfg.template[task_prompt]

            # Determine true label(s) and ambiguous labels
            possible_labels = extract_all_object_from_tags(
                cfg.object, tags=task_prompt_cfg.true_label_tag
            )

            # Ambiguous: multiple possible items
            if task_cfg.ambiguous:
                # fixed_label: human wants a specific item
                if task_cfg.fixed_label:
                    true_intent = [random.choice(list(possible_labels.keys()))]

                    # other labels with the tag
                    ambiguous_intent = [
                        label for label in possible_labels
                        if label not in true_intent
                    ]
                # any item with the tag is fine
                else:
                    true_intent = list(possible_labels.keys())
                    ambiguous_intent = []

                if 'unsafe' in task_cfg:
                    target_loc = task_prompt_cfg.target
                else:
                    target_loc = 'pick-up'
                object_to_be_moved = true_intent  # might be multi-label

            # Unambiguous: only one possible item - randomly sample one from the tag to fill in the template and as the true label
            else:
                true_intent = [random.choice(list(possible_labels.keys()))]
                numeric = possible_labels[true_intent[0]].numeric
                ambiguous_intent = []

                # Fill in the template
                task_prompt = task_prompt.replace(
                    '{numeric}', numeric
                ).replace('{object}', true_intent[0])

                # target location and object to be moved
                if 'drawer' in task_prompt:
                    target_loc = task_prompt.split('drawer'
                                                  )[0].split()[-1] + ' drawer'
                elif 'dispose' in task_prompt:
                    if 'drink' in cfg.object[true_intent[0]].tag:
                        target_loc = 'recycling'
                    elif 'fruit' in cfg.object[true_intent[0]].tag:
                        target_loc = 'compost'
                    else:
                        target_loc = 'landfill'
                elif 'next to' in task_prompt:
                    target_loc = task_prompt.split('next to')[1].split()[1]
                    if target_loc[-1] == '.':
                        target_loc = target_loc[:-1]
                else:
                    target_loc = 'pick-up'
                object_to_be_moved = true_intent[0]

            # Sample objects in the scene
            scene_objects = []
            if hasattr(task_prompt_cfg, 'extra_obj'):
                scene_objects += task_prompt_cfg.extra_obj
            if task_cfg.ambiguous:
                if task_cfg.fixed_label:
                    scene_objects.append(true_intent[0])
                    scene_objects += random.sample(
                        ambiguous_intent,
                        min(target_num_obj - 1, len(ambiguous_intent))
                    )
                else:
                    scene_objects += random.sample(
                        true_intent,
                        min([
                            target_num_obj, cfg.max_num_true_label,
                            len(true_intent)
                        ])
                    )
            else:
                scene_objects.append(true_intent[0])
                possible_labels_tmp = possible_labels.copy()
                possible_labels_tmp.pop(true_intent[0])
                max_extra_obj = 1 if hasattr(
                    task_prompt_cfg, 'extra_obj'
                ) else 2
                scene_objects += random.sample(
                    list(possible_labels_tmp.keys()),
                    min(max_extra_obj, len(possible_labels_tmp.keys()))
                )
            # Sample a random object from the same tag if scene_objects have fewer than 3 objects
            if len(scene_objects) < target_num_obj and hasattr(
                task_prompt_cfg, 'fill_obj_tag'
            ):
                num_extra = target_num_obj - len(scene_objects)
                possible_objects = extract_all_object_from_tags(
                    cfg.object, tags=task_prompt_cfg.fill_obj_tag
                )
                possible_objects = {
                    obj: numeric
                    for obj, numeric in possible_objects.items()
                    if obj not in scene_objects
                }
                scene_objects += random.sample(
                    list(possible_objects.keys()), num_extra
                )

            # Special scene description
            special_scene_description = ''
            if hasattr(task_prompt_cfg, 'special_scene_description'):
                special_scene_description = task_prompt_cfg.special_scene_description

        elif hasattr(task_cfg, 'task_with_labels'):
            task_prompt = random.choice(list(task_cfg.task_with_labels.keys()))
            possible_labels = task_cfg.task_with_labels[task_prompt]

            # Determine true label(s) and ambiguous labels
            # fixed_label: human wants a specific item
            if task_cfg.fixed_label:
                true_intent = [random.choice(possible_labels)]
                ambiguous_intent = [
                    label for label in possible_labels
                    if label not in true_intent
                ]
            # any item with the tag is fine
            else:
                true_intent = possible_labels
                ambiguous_intent = []

            # Sample objects in the scene
            scene_objects = []
            if task_cfg.fixed_label:
                scene_objects.append(true_intent[0])
                scene_objects += random.sample(
                    ambiguous_intent,
                    min(target_num_obj - 1, len(ambiguous_intent))
                )
            else:
                scene_objects += random.sample(
                    true_intent,
                    min([
                        target_num_obj, cfg.max_num_true_label,
                        len(true_intent)
                    ])
                )
            # Sample a random object from the same tag if scene_objects have fewer than 3 objects
            if len(scene_objects) < target_num_obj:
                num_extra = target_num_obj - len(scene_objects)
                tag = cfg.object[true_intent[0]].tag
                possible_objects = extract_all_object_from_tags(
                    cfg.object, tags=tag
                )
                possible_objects = {
                    obj: numeric
                    for obj, numeric in possible_objects.items()
                    if obj not in scene_objects
                }
                scene_objects += random.sample(
                    list(possible_objects.keys()),
                    min(num_extra, len(possible_objects.keys()))
                )
            target_loc = 'pick-up'
            object_to_be_moved = [
                obj for obj in true_intent if obj in scene_objects
            ]

            # No special scene description
            special_scene_description = ''

        else:
            raise 'Unknown task type!'

        # Remove some kinds of objects from the scene
        for obj in cfg.remove_object_from_scene:
            if obj in scene_objects:
                scene_objects.remove(obj)

        # Add more objects if needed
        if len(scene_objects) < target_num_obj:
            num_extra = target_num_obj - len(scene_objects)
            possible_objects = extract_all_object_from_tags(
                cfg.object, tags=cfg.extra_object_tags
            )
            possible_objects = {
                obj: numeric
                for obj, numeric in possible_objects.items()
                if obj not in scene_objects
            }
            scene_objects += random.sample(
                list(possible_objects.keys()), num_extra
            )

        # Filter true labels to only include objects in the scene
        true_intent = [
            label for label in true_intent
            if label in scene_objects or label in cfg.keep_object_from_label
        ]

        # Filter ambiguous labels to only include objects in the scene
        ambiguous_intent = [
            label for label in ambiguous_intent
            if label in scene_objects or label in cfg.keep_object_from_label
        ]

        # Randomize the order of scene objects
        random.shuffle(scene_objects)

        # Get object scene description
        obj_scene_description = ', '.join([
            cfg.object[obj].numeric + ' ' + obj for obj in scene_objects
        ])

        # Add 'and' before last item in obj_scene_description
        obj_scene_description = obj_scene_description.rsplit(', ', -1)
        if len(obj_scene_description) > 1:
            obj_scene_description[-1] = 'and ' + obj_scene_description[-1]
        obj_scene_description = ', '.join(obj_scene_description)

        # # Fill in the other object for winograd prompts
        # if task_category == 'winograd_task':
        #     fill_in_obj = random.choice([
        #         obj for obj in scene_objects if obj not in true_intent
        #     ])
        #     fill_in = task_prompt.split('{')[1].split('}')[0]
        #     task_prompt = task_prompt.replace('{' + fill_in + '}', fill_in_obj)

        # Save data
        init_data_all.append({
            'request': task_prompt,
            'target_loc': target_loc,
            'true_intent': true_intent,
            'ambiguous_intent': ambiguous_intent,
            'task_category': task_category,
            'scene_objects': scene_objects,
            'obj_scene_description': obj_scene_description,
            'special_scene_description': special_scene_description,
        })

        # Log
        logging.info(data_ind)
        # logging.info(
        #     '============ Data {}, new prompt ============'.
        #     format(data_ind + 1)
        # )
        logging.info(f'Scene: {obj_scene_description}')
        logging.info(f'Task: {task_prompt}')
        # logging.info(
        #     'True intent: {}, Ambiguous intent: {}'.format(
        #         true_intent, ambiguous_intent
        #     )
        # )
        if type(object_to_be_moved) == list:
            logging.info(
                'User intent (object): {}'.format(
                    ', '.join(object_to_be_moved)
                )
            )
            for obj in object_to_be_moved:
                scene_objects_lower = [obj.lower() for obj in scene_objects]
                if obj.lower() not in scene_objects_lower:
                    breakpoint()
        else:
            logging.info('User intent (object): {}'.format(object_to_be_moved))
        logging.info('User intent (location): {}'.format(target_loc))
        logging.info('Scene objects: {}'.format(', '.join(scene_objects)))
        logging.info('Task category: {}'.format(task_category))
        # logging.info(
        #     f'================= END {data_ind+1}/{cfg.num_data} =================\n'
        # )
        logging.info('')

    # Save all sampled data
    with open(cfg.data_save_path, 'wb') as handle:
        pickle.dump(init_data_all, handle, protocol=pickle.HIGHEST_PROTOCOL)


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "-cf", "--cfg_file", help="cfg file path", default='', type=str
    )
    args = parser.parse_args()
    cfg = OmegaConf.load(args.cfg_file)
    cfg.data_folder = os.path.dirname(args.cfg_file)
    cfg.parent_data_folder = os.path.dirname(cfg.data_folder)

    # logging
    cfg.logging_path = os.path.join(
        cfg.data_folder, cfg.log_file_name + '.log'
    )
    logging.basicConfig(
        level=logging.INFO, format='%(message)s', handlers=[
            logging.FileHandler(cfg.logging_path, mode='w'),
            logging.StreamHandler()
        ]
    )

    # Save path
    cfg.data_save_path = os.path.join(
        cfg.data_folder, cfg.data_save_name + '.pkl'
    )

    # Seed
    random.seed(cfg.seed)

    # run
    main(cfg)
